package lexer.setup;

import java.util.*;
import java.io.*;

/**
 *  TokenSetup class is used to read the tokens from file <i>tokens</i>
 *  and automatically build the 2 classes/files <i>TokenType.java</i> 
 *  and <i>Tokens.java</i><br>
 *  Therefore, if there is any change to the tokens then we only need to
 *  modify the file <i>tokens</i> and run this program again before using the
 *  compiler.
 *  <p>
 *  CSC 413 Fall 2015 Project 2 changes to the tokens file.
 *  <p>
 *  Below is a listing of the changes to the tokens input file for the CSC 413
 *  Fall 2015 Project 2. Since comments cannot be added to the tokens file, they
 *  are added here. 
 *  <p>
 *  1. Added float identifier reserved word for float datatype variables.
 *  <p>
 *  2. Added float literal values.
 *  <p>
 *  3. Added Scientific literal values. These values are assigned to float 
 *     variables.
 *  <p>
 *  4. Added char identifier reserved word for character datatype variables.
 *  <p>
 *  5. Added char literal values which are a single character enclosed in single
 *     quotes. 
 *  <p>
 *  6. Added string identifier reserved word for string datatype variables.
 *  <p>
 *  7. Added string literal values which are any number of characters, including
 *     zero, enclosed in double quotes. 
 *  <p>
 *  8. Added  greater-than and greater-than or Equal reserved words.
 * 
*/
public class TokenSetup {
    /** type String - the Token type, first entry in tokens file.   */
    private String type;
    /** value String - the Token value, second entry in tokens file.   */
    private String value;
    /** tokenCount int - count of Tokens in tokens file.  */
    private int tokenCount = 0;
    /** in BufferedReader - tokens input file.   */
    private BufferedReader in;
    /** table PrintWriter - TokenType.java file.  */
    private PrintWriter table; 
    /** symbols PrintWriter - Tokens.java file.  */
    private PrintWriter symbols;

    public static void main(String args[]) {
        new TokenSetup().initTokenClasses();
    }

    TokenSetup() {
        try {
            System.out.println("User's current working directory: " + System.getProperty("user.dir"));	
            String sep = System.getProperty("file.separator"); // fetch seperated used in this OS. 
            
            // Open tokens input file and create two output files, TokenType.java and Tokens.java. 
            in = new BufferedReader( new FileReader("lexer" + sep + "setup" + sep + "tokens"));
            table = new PrintWriter(new FileOutputStream("lexer" + sep + "TokenType.java"));
            symbols = new PrintWriter(new FileOutputStream("lexer" + sep + "Tokens.java"));
        } catch (Exception e) {
        	System.out.println(e);
        }
    }

/**
 *  Read next line which contains token information.<br>
 *  Each line will contain the token type used in lexical analysis and
 *  the printString of the token: e.g.<br><ul>
 *  <li>Program program</li>
 *  <li>Int int</li>
 *  <li>BOOLean boolean</li></ul>
 * 
 *  @throws IOException is thrown to indicate the end of the tokens files.
 *  @throws NullPointerException is thrown to indicate the end of tokens file.
 *  @throws NoSuchElementException is thrown if there are not 2 Strings per line.
*/
    public void getNextToken() throws IOException {
        try {
            // Create a StringTokenizer object using space as the delimiter for
            // easy String seperation. 
            StringTokenizer st = new StringTokenizer(in.readLine());
            type = st.nextToken();
            value = st.nextToken();
        } catch (NoSuchElementException e) {
            System.out.println("***tokens file does not have 2 strings per line***");
            System.exit(1);
        } catch (NullPointerException ne) {
            // attempt to build new StringTokenizer when at end of file
            throw new IOException("***End of File***");
        }
        tokenCount++;
    }

/**
 *  initTokenClasses will create the 2 files
*/
    public void initTokenClasses() {
        // Write to two Java program files the program beginning code. 
        // Write to TokenType.java
        table.println("package lexer;");
        table.println(" ");
        table.println("/**");
        table.println(" *  This file is automatically generated<br>");
        table.println(" *  it contains the table of mappings from token");
        table.println(" *  constants to their Symbols");
        table.println("*/");
        table.println("public class TokenType {");
        table.println("   public static java.util.HashMap<Tokens,Symbol> tokens = new java.util.HashMap<Tokens,Symbol>();");
        table.println("   public TokenType() {");
        // Write to Tokens.java
        symbols.println("package lexer;");
        symbols.println(" ");
        symbols.println("/**");
        symbols.println(" *  This file is automatically generated<br>");
        symbols.println(" *  - it contains the enumeration of all of the tokens");
        symbols.println("*/");
        symbols.println("public enum Tokens {");
        symbols.print("  BogusToken");

        while (true) {
            try {
                getNextToken();
            } catch (IOException e) {break;}

            String symType = "Tokens." + type;

            table.println("     tokens.put(" + symType +
                ", Symbol.symbol(\"" + value + "\"," + symType + "));");

            if (tokenCount % 5 == 0) {
            	symbols.print(",\n    "+ type);
            } else {
            	symbols.print("," + type);
            }
        }

        // Write to two Java program files the program ending code.
        table.println("   }");
        table.println("}");
        table.close();
        symbols.println("\n}");
        symbols.close();
        try {
            in.close();
        } catch (Exception e) {}
    }
}

